#nullable enable
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using FFmpegInteropX;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Windows.UI.Xaml.Media;
using WinTube.Model;
using WinTube.Services;
using YoutubeExplode;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.Streams;

namespace WinTube.ViewModels;

public partial class ViewViewModel : ObservableRecipient, IRecipient<VideoSelectedMessage>
{
    private readonly YoutubeClient _client;
    private readonly NavigationService _navigationService;

    private Uri? _videoUri;
    public event EventHandler<ShareRequest>? ShareRequested;

    [ObservableProperty] public partial IEnumerable<NamedMediaSource> AudioStreams { get; private set; }
    [ObservableProperty] public partial IEnumerable<NamedMediaSource> VideoStreams { get; private set; }
    [ObservableProperty] public partial List<NamedMediaSource> CaptionSources { get; private set; } = [];

    [ObservableProperty] private bool _isLive;
    [ObservableProperty] private Uri? _livestreamSource;

    [ObservableProperty] private string? _title;
    [ObservableProperty] private ImageSource? _posterSource;

    [ObservableProperty] private string? _channelTitle;
    [ObservableProperty] private Uri? _channelPicture;

    [ObservableProperty] private long? _likeCount;

    [ObservableProperty] private DateTimeOffset _uploadDate;
    [ObservableProperty] private long? _viewCount;
    [ObservableProperty] private string? _description;

    [ObservableProperty] private bool _isLoading = true;

    public ViewViewModel(YoutubeClient client, NavigationService navigationService)
    {
        _client = client;
        _navigationService = navigationService;

        IsActive = true;
    }

    public async void Receive(VideoSelectedMessage message)
    {
        PosterSource = message.SelectedVideoSearchResult.Thumbnail;
        IsLoading = false;

        try
        {
            var videoId = message.SelectedVideoSearchResult.VideoId;

            var videoTask = _client.Videos.GetAsync(videoId);
            var manifestTask = _client.Videos.Streams.GetManifestAsync(videoId);

            // check if it's a live stream
            if (message.SelectedVideoSearchResult.Duration != default)
            {
                var streamManifest = await manifestTask;
                {
                    await AddCaptionSourcesAsync(videoId);
                    AudioStreams = CreateAudioStreams(streamManifest);
                    VideoStreams = AddVideoStreams(streamManifest);
                }
            }
            else
            {
                IsLive = true;
                LivestreamSource = new Uri(await _client.Videos.Streams.GetHttpLiveStreamUrlAsync(videoId));
            }

            var video = await videoTask;
            {
                _videoUri = new Uri(video.Url);

                Title = video.Title;
                ChannelTitle = video.Author.ChannelTitle;
                UploadDate = video.UploadDate;
                LikeCount = video.Engagement.LikeCount;
                ViewCount = video.Engagement.ViewCount;
                Description = video.Description;
            }

            var channelTask = _client.Channels.GetAsync(video.Author.ChannelId);

            var channel = await channelTask;
            {
                ChannelPicture = new Uri(
                    channel.Thumbnails.OrderByDescending(t => t.Resolution.Area).First().Url
                );
            }
        }
        catch (Exception ex)
        {
            Description = ex.ToString();
            IsLoading = false;
        }
    }

    private async Task AddCaptionSourcesAsync(VideoId videoId)
    {
        var trackManifest = await _client.Videos.ClosedCaptions.GetManifestAsync(videoId);
        foreach (var track in trackManifest.Tracks)
            CaptionSources.Add(new(track.Language.Name + (track.IsAutoGenerated ? " (auto-generated)" : string.Empty), "srt", track.Url + "&fmt=srt"));
    }

    private IEnumerable<NamedMediaSource> CreateAudioStreams(StreamManifest manifest) => manifest
                .GetAudioStreams()
                .OrderByDescending(x => x.IsAudioLanguageDefault ?? false)
                .ThenBy(x => x.AudioLanguage.GetValueOrDefault().Code)
                .ThenBy(x => x.Bitrate.KiloBitsPerSecond)
                .Select(x =>
                {
                    var language = x.AudioLanguage.HasValue ? x.AudioLanguage.Value.Name : "unknown";
                    var name = $"{language} • {x.Bitrate.KiloBitsPerSecond:F2} kbps";
                    if (x.IsAudioLanguageDefault == true)
                        name += " (original language)";

                    return new NamedMediaSource(name, x.Container.Name, x.Url);
                });

    private IEnumerable<NamedMediaSource> AddVideoStreams(StreamManifest manifest) => manifest
            .GetVideoStreams()
            .OrderBy(x => x.VideoResolution.Area)
            .Select(x => new NamedMediaSource($"{x.VideoQuality} ({x.Container.Name})", x.Container.Name, x.Url));

    [RelayCommand]
    private void OnShare() => ShareRequested?.Invoke(this, new(Title, Description, _videoUri));

    [RelayCommand]
    private void OnBack()
    {
        _navigationService.GoBack();

        WeakReferenceMessenger.Default.Send(new ListModeChangeMessage(false));
    }
}