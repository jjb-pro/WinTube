#nullable enable
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Web;
using Windows.UI.Xaml.Media;
using WinTube.Model;
using WinTube.Services;
using YoutubeExplode;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;
using YoutubeExplode.Videos.Streams;

namespace WinTube.ViewModels;

public partial class ViewViewModel : ObservableRecipient, IRecipient<VideoSelectedMessage>
{
    private readonly YoutubeClient _client;
    private readonly NavigationService _navigationService;

    private Uri? _videoUri;
    public event EventHandler<ShareRequest>? ShareRequested;

    [ObservableProperty] public partial IEnumerable<INamedStreamSource>? AudioSources { get; private set; }
    [ObservableProperty] public partial IEnumerable<INamedStreamSource>? VideoSources { get; private set; }
    [ObservableProperty] public partial IEnumerable<INamedStreamSource>? SubtitleSources { get; private set; }

    [ObservableProperty] private bool _isLive;
    [ObservableProperty] private Uri? _livestreamSource;

    [ObservableProperty] private string? _title;
    [ObservableProperty] private ImageSource? _posterSource;

    [ObservableProperty] private string? _channelTitle;
    [ObservableProperty] private Uri? _channelPicture;

    [ObservableProperty] private long? _likeCount;

    [ObservableProperty] private DateTimeOffset _uploadDate;
    [ObservableProperty] private long? _viewCount;
    [ObservableProperty] private string? _description;

    [ObservableProperty] private bool _isLoading = true;

    public ViewViewModel(YoutubeClient client, NavigationService navigationService)
    {
        _client = client;
        _navigationService = navigationService;

        IsActive = true;
    }

    public async void Receive(VideoSelectedMessage message)
    {
        PosterSource = message.SelectedVideoSearchResult.Thumbnail;
        IsLoading = false;

        try
        {
            var videoId = message.SelectedVideoSearchResult.VideoId;

            var videoTask = _client.Videos.GetAsync(videoId);
            var manifestTask = _client.Videos.Streams.GetManifestAsync(videoId);

            // check if it's a live stream
            if (message.SelectedVideoSearchResult.Duration != default)
            {
                var streamManifest = await manifestTask;
                {
                    AudioSources = CreateNamedAudioSources(streamManifest);
                    VideoSources = CreateNamedVideoSources(streamManifest);
                    SubtitleSources = CreateNamedSubtitleSources(await _client.Videos.ClosedCaptions.GetManifestAsync(videoId));
                }
            }
            else
            {
                IsLive = true;
                LivestreamSource = new Uri(await _client.Videos.Streams.GetHttpLiveStreamUrlAsync(videoId));
            }

            var video = await videoTask;
            {
                _videoUri = new Uri(video.Url);

                Title = video.Title;
                ChannelTitle = video.Author.ChannelTitle;
                UploadDate = video.UploadDate;
                LikeCount = video.Engagement.LikeCount;
                ViewCount = video.Engagement.ViewCount;
                Description = video.Description;
            }

            var channelTask = _client.Channels.GetAsync(video.Author.ChannelId);

            var channel = await channelTask;
            {
                ChannelPicture = new Uri(
                    channel.Thumbnails.OrderByDescending(t => t.Resolution.Area).First().Url
                );
            }
        }
        catch (Exception ex)
        {
            Description = ex.ToString();
            IsLoading = false;
        }
    }

    private IEnumerable<NamedUriStreamSource> CreateNamedSubtitleSources(ClosedCaptionManifest manifest) => manifest.Tracks
         .OrderByDescending(x => x.Language.Name)
         .ThenBy(x => x.IsAutoGenerated)
         .Select(x =>
         {
             var uriBuilder = new UriBuilder(x.Url);
             var query = HttpUtility.ParseQueryString(uriBuilder.Query);

             query["fmt"] = "srt";
             uriBuilder.Query = query.ToString();

             return new NamedUriStreamSource(x.Language.Name + (x.IsAutoGenerated ? " (auto-generated)" : string.Empty), uriBuilder.Uri);
         });

    // ToDo: move to service
    private IEnumerable<NamedYouTubeStreamSource<IAudioStreamInfo>> CreateNamedAudioSources(StreamManifest manifest) => manifest
        .GetAudioStreams()
        .OrderByDescending(x => x.IsAudioLanguageDefault ?? false)
        .ThenBy(x => x.AudioLanguage.GetValueOrDefault().Code)
        .ThenBy(x => x.Bitrate.KiloBitsPerSecond)
        .Select(x =>
        {
            var language = x.AudioLanguage.HasValue ? x.AudioLanguage.Value.Name : "unknown";
            var name = $"{language} • {x.Bitrate.KiloBitsPerSecond:F2} kbps";
            if (x.IsAudioLanguageDefault == true)
                name += " (original language)";

            return new NamedYouTubeStreamSource<IAudioStreamInfo>(name, _client, x);
        });

    private IEnumerable<NamedYouTubeStreamSource<IVideoStreamInfo>> CreateNamedVideoSources(StreamManifest manifest) => manifest
        .GetVideoStreams()
        .OrderBy(x => x.VideoResolution.Area)
        .Select(x => new NamedYouTubeStreamSource<IVideoStreamInfo>($"{x.VideoQuality} ({x.Container.Name})", _client, x));

    [RelayCommand]
    private void OnShare() => ShareRequested?.Invoke(this, new(Title, Description, _videoUri));

    [RelayCommand]
    private void OnBack()
    {
        _navigationService.GoBack();

        WeakReferenceMessenger.Default.Send(new ListModeChangeMessage(false));
    }
}